// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
/*
 * Copyright (c) 2024 InMys
 *
 */

/dts-v1/;

#include <dt-bindings/gpio/gpio.h>
#include <dt-bindings/pwm/pwm.h>
#include <dt-bindings/pinctrl/rockchip.h>
#include <dt-bindings/input/rk-input.h>
#include <dt-bindings/display/drm_mipi_dsi.h>
#include <dt-bindings/display/rockchip_vop.h>
#include <dt-bindings/sensor-dev.h>
#include "dt-bindings/usb/pd.h"
#include "rk3588.dtsi"
#include "rk3588-rk806-single.dtsi"
#include "rk3588-linux.dtsi"

#define HDMI0 1
#define HDMI1 1
#define DSI 0

#define PCIE2_0 1
#define PCIE2_1 0
#define SATA 1

#define PCIE3_0 1
#define PCIE3_1 1

#define ETH_100M 1
#define ETH_1G 1

#define SDCARD 1

/* csi camera on J4 som connector */
#define J4_CSI_CAM 1
/* csi camera on J3 som connector */
#define J3_CSI_CAM 1

#define HDMIRX 1


/ {
	compatible = "inmys,rk3588-cs-som", "rockchip,rk3588";

	/delete-node/ chosen;

	aliases {
		mmc0 = &sdhci; /*emmc*/
		mmc1 = &sdmmc; /*sdcard*/
		ethernet0 = &gmac0;
		ethernet1 = &gmac1;
		can0 = &can0;
		can1 = &can1;
	};

	gpio_leds: gpio-leds {
		compatible = "gpio-leds";
		pinctrl-names = "default";

		status-led-green {
			gpios = <&gpio1 RK_PD3 GPIO_ACTIVE_HIGH>;
			linux,default-trigger = "heartbeat";
			default-state = "on";
		};
	};
};

/* power supply */
/{
	V3P3: PMIC_EXT_EN_OUT {
		/* enable 3v3 main power on mother board, by pmic pin "EXT_EN" */
		/* pin 112 on J1 connector */
		compatible = "regulator-fixed";
		regulator-name = "PMIC_EXT_EN_OUT";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		regulator-boot-on;
	};

	vcc5v0_sys: vcc4v0_sys: vcc4v0-sys-regulator {
		/* RT5789AGQUF: input: cardsom_vdd_in, output: 4V (rockcip rk806 recomendation) */
		compatible = "regulator-fixed";
		regulator-name = "vcc4v0_sys";
		regulator-always-on;
		regulator-boot-on;
		regulator-min-microvolt = <4000000>;
		regulator-max-microvolt = <4000000>;
	};

	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3-regulator {
		compatible = "regulator-fixed";
		regulator-name = "vcc_1v1_nldo_s3";
		regulator-always-on;
		regulator-boot-on;
		regulator-min-microvolt = <1100000>;
		regulator-max-microvolt = <1100000>;
		vin-supply = <&vcc4v0_sys>;
	};
};

&i2c0 {
	status = "okay";
	pinctrl-names = "default";
	pinctrl-0 = <&i2c0m2_xfer>;

	vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 {
		compatible = "rockchip,rk8602";
		reg = <0x42>;
		vin-supply = <&vcc4v0_sys>;
		regulator-compatible = "rk860x-reg";
		regulator-name = "vdd_cpu_big0_s0";
		regulator-min-microvolt = <550000>;
		regulator-max-microvolt = <1050000>;
		regulator-ramp-delay = <2300>;
		rockchip,suspend-voltage-selector = <1>;
		regulator-boot-on;
		regulator-always-on;
		regulator-state-mem {
			regulator-off-in-suspend;
		};
	};

	vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 {
		compatible = "rockchip,rk8603";
		reg = <0x43>;
		vin-supply = <&vcc4v0_sys>;
		regulator-compatible = "rk860x-reg";
		regulator-name = "vdd_cpu_big1_s0";
		regulator-min-microvolt = <550000>;
		regulator-max-microvolt = <1050000>;
		regulator-ramp-delay = <2300>;
		rockchip,suspend-voltage-selector = <1>;
		regulator-boot-on;
		regulator-always-on;
		regulator-state-mem {
			regulator-off-in-suspend;
		};
	};
	/* i2c0 has other devices - see bellow! */
};

&i2c1 {
	status = "okay";
	pinctrl-names = "default";
	pinctrl-0 = <&i2c1m2_xfer>;

	vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 {
		compatible = "rockchip,rk8602";
		reg = <0x42>;
		vin-supply = <&vcc4v0_sys>;
		regulator-compatible = "rk860x-reg";
		regulator-name = "vdd_npu_s0";
		regulator-min-microvolt = <550000>;
		regulator-max-microvolt = <950000>;
		regulator-ramp-delay = <2300>;
		rockchip,suspend-voltage-selector = <1>;
		regulator-boot-on;
		regulator-always-on;
		regulator-state-mem {
			regulator-off-in-suspend;
		};
	};
	/* i2c1 has other devices - see bellow! */
};

&cpu_l0 {
	cpu-supply = <&vdd_cpu_lit_s0>;
	mem-supply = <&vdd_cpu_lit_mem_s0>;
};

&cpu_b0 {
	cpu-supply = <&vdd_cpu_big0_s0>;
	mem-supply = <&vdd_cpu_big0_mem_s0>;
};

&cpu_b2 {
	cpu-supply = <&vdd_cpu_big1_s0>;
	mem-supply = <&vdd_cpu_big1_mem_s0>;
};

&avdd_0v75_s0 {
	regulator-state-mem {
		regulator-on-in-suspend;
		regulator-suspend-microvolt = <837500>;
	};
};

&avcc_1v8_s0 {
	regulator-state-mem {
		regulator-on-in-suspend;
		regulator-suspend-microvolt = <1800000>;
	};
};

&vcc_1v8_s0 {
	regulator-state-mem {
		regulator-on-in-suspend;
		regulator-suspend-microvolt = <1800000>;
	};
};

&vcc_3v3_s0 {
	regulator-state-mem {
		regulator-on-in-suspend;
		regulator-suspend-microvolt = <3300000>;
	};
};

&vdd_log_s0 {
	regulator-state-mem {
		regulator-on-in-suspend;
		regulator-suspend-microvolt = <750000>;
	};
};

&vdd_ddr_pll_s0 {
	regulator-state-mem {
		regulator-on-in-suspend;
		regulator-suspend-microvolt = <850000>;
	};
};

#if 0
&vdd_0v75_s0 {
	regulator-min-microvolt = <837500>;
	regulator-max-microvolt = <837500>;
};
#endif
/* end power supply */


#if PCIE3_0
&pcie30phy {
	rockchip,pcie30-phymode = <PHY_MODE_PCIE_NANBNB>;
	status = "okay";
};

&pcie3x4 {
	num-lanes = <2>;
	/*reset-gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;*/
	reset-gpios = <&gpio4 RK_PA2 GPIO_ACTIVE_HIGH>;
	vpcie3v3-supply = <&V3P3>;
	status = "okay";
};
#if PCIE3_1
&pcie3x2 {
	num-lanes = <2>;
	reset-gpios = <&gpio4 RK_PA5 GPIO_ACTIVE_HIGH>;
	vpcie3v3-supply = <&V3P3>;
	status = "okay";
};
#endif // end PCIE3_1
#endif // end PCIE3_0


&i2c0 {
	rtc68: pcf8523@68 {
		compatible = "nxp,pcf8523";
		reg = <0x68>;
		quartz-load-femtofarads = <12500>;
		/*rtcint GPIO0_B0*/
		interrupt-parent = <&gpio0>;
		interrupts = <8 IRQ_TYPE_LEVEL_LOW>;
	};
	eeprom50: eeprom@50 {
		compatible = "atmel,24c02";
		reg = <0x50>;
	};
};


#if HDMI0
&hdmi0 {
	status = "okay";
	pinctrl-0 = <&hdmim0_tx0_cec &hdmim0_tx0_hpd &hdmim0_tx0_scl &hdmim0_tx0_sda>;
};

&hdmi0_in_vp0 {
	status = "okay";
};

&route_hdmi0 {
	status = "okay";
};

&hdptxphy_hdmi0 {
	status = "okay";
};


&i2s5_8ch {
	status = "okay";
};

/{ 
	hdmi0_sound: hdmi0-sound {
		status = "okay";
		compatible = "rockchip,hdmi";
		rockchip,mclk-fs = <128>;
		rockchip,card-name = "rockchip-hdmi0";
		rockchip,cpu = <&i2s5_8ch>;
		rockchip,codec = <&hdmi0>;
		rockchip,jack-det;
	};
};

#endif // end HDMI0

#if HDMI1
&hdmi1 {
	status = "okay";
	pinctrl-0 = <&hdmim0_tx1_hpd &hdmim2_tx1_scl &hdmim2_tx1_sda>;
	//pinctrl-0 = <&hdmim2_tx1_cec &hdmim0_tx1_hpd &hdmim1_tx1_scl &hdmim1_tx1_sda>;
	cec-enable = "false";
};

&hdmi1_in_vp1 {
	status = "okay";
};

&route_hdmi1 {
	status = "okay";
};

&hdptxphy_hdmi1 {
	status = "okay";
};

&i2s6_8ch {
	status = "okay";
};

/{
	hdmi1_sound: hdmi1-sound {
		status = "okay";
		compatible = "rockchip,hdmi";
		rockchip,mclk-fs = <128>;
		rockchip,card-name = "rockchip-hdmi1";
		rockchip,cpu = <&i2s6_8ch>;
		rockchip,codec = <&hdmi1>;
		rockchip,jack-det;
	};
};

#endif // end HDMI1

&pwm0 {
	pinctrl-0 = <&pwm0m1_pins>;
};

&pwm12 {
	pinctrl-0 = <&pwm12m1_pins>;
};

&pwm13 {
	pinctrl-0 = <&pwm13m1_pins>;
};


#if DSI
&dsi0 {
        status = "okay";

	ports {
		#address-cells = <1>;
		#size-cells = <0>;
		port@1 {
			reg = <1>;
			dsi_out_panel: endpoint {
				remote-endpoint = <&panel_in_dsi>;
			};
		};
	};
};

&mipi_dcphy0 {
	status = "okay";
};


&dsi0_in_vp2 {
	status = "okay";
};


&route_dsi0 {
	status = "okay";
	connect = <&vp2_out_dsi0>;
};

&vp2_out_dsi0{
	status = "okay";
};

#endif // end DSI

#if HDMI0 || HDMI1 || DSI
&vop {
	status = "okay";
	vop-supply = <&vdd_log_s0>;
};

&vop_mmu {
	status = "okay";
};


&vp0 {
	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER0>;
	cursor-win-id = <ROCKCHIP_VOP2_ESMART0>;
};

&vp1 {
	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER1>;
	cursor-win-id = <ROCKCHIP_VOP2_ESMART1>;
};

&vp2 {
	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>;
	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER2>;
	cursor-win-id = <ROCKCHIP_VOP2_ESMART2>;
};

&vp3 {
	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER3>;
	cursor-win-id = <ROCKCHIP_VOP2_ESMART3>;
};

#endif // end HDMI0 || HDMI1 || DSI


#if 1
&gpu {
	mali-supply = <&vdd_gpu_s0>;
	mem-supply = <&vdd_gpu_mem_s0>;
	status = "okay";
};
#else
&gpu_mali {
	mali-supply = <&vdd_gpu_s0>;
	mem-supply = <&vdd_gpu_mem_s0>;
	status = "okay";
};
#endif

/* emmc */
&sdhci {
	bus-width = <8>;
	no-sdio;
	no-sd;
	non-removable;
	max-frequency = <200000000>;
	mmc-hs400-1_8v;
	mmc-hs400-enhanced-strobe;
	mmc-hs200-1_8v;
	status = "okay";
	vmmc-supply = <&vcc_3v3_s3>;
};

#if SDCARD

/{
	sd_pwren: sd_pwren-regulator {
		compatible = "regulator-fixed";
		regulator-name = "sd_pwren";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		vin-supply = <&vcc_3v3_s3>;
		gpio = <&gpio0 RK_PA0 GPIO_ACTIVE_HIGH>;
		enable-active-low;
	};
};

/* sdcard */
&sdmmc {
	max-frequency = <200000000>;
	no-sdio;
	no-mmc;
	bus-width = <4>;
	cap-mmc-highspeed;
	cap-sd-highspeed;
	disable-wp;
	sd-uhs-sdr104;
	vmmc-supply = <&sd_pwren>;
	vqmmc-supply = <&vccio_sd_s0>;
	pinctrl-names = "default";
	pinctrl-0 = <&sdmmc_bus4 &sdmmc_clk &sdmmc_cmd &sdmmc_det>;
	status = "okay";
};
#endif // end SDCARD


&rknpu {
	rknpu-supply = <&vdd_npu_s0>;
	mem-supply = <&vdd_npu_mem_s0>;
	status = "okay";
};

&rknpu_mmu {
	status = "okay";
};


&iep {
	status = "okay";
};

&iep_mmu {
	status = "okay";
};

&jpegd {
	status = "okay";
};

&jpegd_mmu {
	status = "okay";
};

&jpege_ccu {
	status = "okay";
};

&jpege0 {
	status = "okay";
};

&jpege0_mmu {
	status = "okay";
};

&jpege1 {
	status = "okay";
};

&jpege1_mmu {
	status = "okay";
};

&jpege2 {
	status = "okay";
};

&jpege2_mmu {
	status = "okay";
};

&jpege3 {
	status = "okay";
};

&jpege3_mmu {
	status = "okay";
};

&mpp_srv {
	status = "okay";
};

&rga3_core0 {
	status = "okay";
};

&rga3_0_mmu {
	status = "okay";
};

&rga3_core1 {
	status = "okay";
};

&rga3_1_mmu {
	status = "okay";
};

&rga2 {
	status = "okay";
};

&rkvdec_ccu {
	status = "okay";
};

&rkvdec0 {
	status = "okay";
};

&rkvdec0_mmu {
	status = "okay";
};

&rkvdec1 {
	status = "okay";
};

&rkvdec1_mmu {
	status = "okay";
};

&rkvenc_ccu {
	status = "okay";
};

&rkvenc0 {
	status = "okay";
	venc-supply = <&vdd_vdenc_s0>;
	mem-supply = <&vdd_vdenc_mem_s0>;
};

&rkvenc0_mmu {
	status = "okay";
};

&rkvenc1 {
	status = "okay";
	venc-supply = <&vdd_vdenc_s0>;
	mem-supply = <&vdd_vdenc_mem_s0>;
};

&rkvenc1_mmu {
	status = "okay";
};

&av1d {
	status = "okay";
};

&av1d_mmu {
	status = "okay";
};

&saradc {
	status = "okay";
	vref-supply = <&vcc_1v8_s0>;
};

&tsadc {
	status = "okay";
};


#if ETH_100M
&mdio0 {
	rmii_phy0: phy@0 {
		compatible = "ethernet-phy-ieee802.3-c22";
		reg = <0x0>;
		clocks = <&cru REFCLKO25M_ETH0_OUT>;
	};
};

&gmac0 {
	phy-mode = "rmii";
	clock_in_out = "output";
#if 0
	//orig
	clocks = <&cru CLK_GMAC_125M>, <&cru CLK_GMAC_50M>, ...
	clock-names = "stmmaceth", "clk_mac_ref", ...
#else
	/* В "rmii" режиме драйвер перестраивает "stmmaceth" на 50МГц,
	   но этот же клок (CLK_GMAC_125M) используется и в gmac1, а там он 
	   в "rgmii" режиме нужен 125Мгц.
	   хак: Поменял клоки "stmmaceth" и "clk_mac_ref" для gmac0 местами */
	// clocks = <&cru CLK_GMAC_125M>, <&cru CLK_GMAC_50M>,
	clock-names = "clk_mac_ref", "stmmaceth",
		"pclk_mac", "aclk_mac",
		"ptp_ref";
#endif
	snps,reset-gpio = <&gpio4 RK_PC6 GPIO_ACTIVE_LOW>;
	snps,reset-active-low;
	snps,reset-delays-us = <0 20000 100000>;
	pinctrl-names = "default";
	pinctrl-0 = <&gmac0_miim
			&gmac0_clkinout /*4 RK_PC3 ETHCLK*/
			&eth0_pins      /*2 RK_PC3 RMII_ETH.REFCLK*/
			&gmac0_tx_bus2
			&gmac0_rx_bus2
			>;
	phy-handle = <&rmii_phy0>;
	status = "okay";
};
#endif // end ETH_100M

#if PCIE2_0
&combphy0_ps {
	status = "okay";
};
&pcie2x1l2 {
	status = "okay";
	reset-gpios = <&gpio1 RK_PB4 GPIO_ACTIVE_HIGH>;
	/*rockchip,skip-scan-in-resume;*/
};
#endif // end PCIE2_0

#if PCIE2_1
&combphy1_ps {
	status = "okay";
};
&pcie2x1l0 {
	status = "okay";
	/*reset-gpios = <&gpio1 RK_PB4 GPIO_ACTIVE_HIGH>;*/
	/*rockchip,skip-scan-in-resume;*/
};
#endif // end PCIE2_1

#if SATA
&combphy2_psu {
	status = "okay";
};

&sata2 {
	status = "okay";
};
#endif // end SATA


&rockchip_suspend {
	compatible = "rockchip,pm-rk3588";
	status = "okay";
	rockchip,sleep-debug-en = <1>;
	rockchip,sleep-mode-config = <
		(0
		| RKPM_SLP_ARMOFF_DDRPD
		)
	>;
	rockchip,wakeup-config = <
		(0
		| RKPM_GPIO_WKUP_EN
		| RKPM_USB_WKUP_EN
		)
	>;
};

#if J4_CSI_CAM || J3_CSI_CAM
&rkcif {
	status = "okay";
};


&rkcif_mmu {
	status = "okay";
};
#endif // end J4_CSI_CAM | J3_CSI_CAM

#if J4_CSI_CAM
&rkisp0 {
	status = "okay";
};

&isp0_mmu {
	status = "okay";
};

&rkisp0_vir0 {
	status = "okay";
		port {
		#address-cells = <1>;
		#size-cells = <0>;

		isp0_in: endpoint@0 {
			reg = <0>;
			remote-endpoint = <&mipi0_lvds_sditf>;
		};
	};
};


&rkcif_mipi_lvds_sditf {
	status = "okay";

	port {
		mipi0_lvds_sditf: endpoint {
			remote-endpoint = <&isp0_in>;
		};
	};
};


&rkcif_mipi_lvds {
	status = "okay";

	port {
		cif_mipi_in0: endpoint {
			remote-endpoint = <&mipi0_csi2_output>;
		};
	};
};

&mipi0_csi2 {
	status = "okay";

	ports {
		#address-cells = <1>;
		#size-cells = <0>;

		port@0 {
			reg = <0>;
			#address-cells = <1>;
			#size-cells = <0>;

			mipi0_csi2_input: endpoint@0 {
				reg = <0>;
				remote-endpoint = <&csidcphy0_out>;
			};
		};

		port@1 {
			reg = <1>;
			#address-cells = <1>;
			#size-cells = <0>;

			mipi0_csi2_output: endpoint@0 {
				reg = <0>;
				remote-endpoint = <&cif_mipi_in0>;
			};
		};
	};
};

&csi2_dcphy0 {
	status = "okay";

	ports {
		#address-cells = <1>;
		#size-cells = <0>;
		port@0 {
			reg = <0>;
			#address-cells = <1>;
			#size-cells = <0>;

			csidcphy0_in: endpoint@0 {
				reg = <0>;
				remote-endpoint = <&j4_csi_cam_out>;
				data-lanes = <1 2 3 4>;
			};
		};
		port@1 {
			reg = <1>;
			#address-cells = <1>;
			#size-cells = <0>;

			csidcphy0_out: endpoint@0 {
				reg = <0>;
				remote-endpoint = <&mipi0_csi2_input>;
			};
		};
	};
};

#endif // J4_CSI_CAM end

#if J3_CSI_CAM
&rkisp1 {
	status = "okay";
};

&isp1_mmu {
	status = "okay";
};

&rkisp1_vir0 {
	status = "okay";
		port {
		#address-cells = <1>;
		#size-cells = <0>;

		isp1_in: endpoint@0 {
			reg = <0>;
			remote-endpoint = <&mipi1_lvds_sditf>;
		};
	};
};


&rkcif_mipi_lvds1_sditf {
	status = "okay";

	port {
		mipi1_lvds_sditf: endpoint {
			remote-endpoint = <&isp1_in>;
		};
	};
};


&rkcif_mipi_lvds1 {
	status = "okay";

	port {
		cif_mipi_in1: endpoint {
			remote-endpoint = <&mipi1_csi2_output>;
		};
	};
};

&mipi1_csi2_hw {
	status = "okay";
};

&mipi1_csi2 {
	status = "okay";

	ports {
		#address-cells = <1>;
		#size-cells = <0>;

		port@0 {
			reg = <0>;
			#address-cells = <1>;
			#size-cells = <0>;

			mipi1_csi2_input: endpoint@0 {
				reg = <0>;
				remote-endpoint = <&csidcphy1_out>;
			};
		};

		port@1 {
			reg = <1>;
			#address-cells = <1>;
			#size-cells = <0>;

			mipi1_csi2_output: endpoint@0 {
				reg = <0>;
				remote-endpoint = <&cif_mipi_in1>;
			};
		};
	};
};

&csi2_dcphy1 {
	status = "okay";

	ports {
		#address-cells = <1>;
		#size-cells = <0>;
		port@0 {
			reg = <0>;
			#address-cells = <1>;
			#size-cells = <0>;

			csidcphy1_in: endpoint@0 {
				reg = <0>;
				remote-endpoint = <&j3_csi_cam_out>;
				data-lanes = <1 2>;
			};
		};
		port@1 {
			reg = <1>;
			#address-cells = <1>;
			#size-cells = <0>;

			csidcphy1_out: endpoint@0 {
				reg = <0>;
				remote-endpoint = <&mipi1_csi2_input>;
			};
		};
	};
};

#endif // J3_CSI_CAM end


&uart0 {
	status = "okay";
	pinctrl-0 = <&uart0m0_xfer>;
};

&uart1 {
	status = "okay";
	pinctrl-0 = <&uart1m1_xfer &uart1m1_ctsn &uart1m1_rtsn>;
};

/* console */
&uart2 {
	status = "okay";
	pinctrl-0 = <&uart2m0_xfer>;
};

&uart5 {
	status = "okay";
	pinctrl-0 = <&uart5m1_xfer>;
};

&uart6 {
	status = "okay";
	/*pinctrl-0 = <&uart6m1_xfer &uart6m1_ctsn &uart6m1_rtsn>;*/
	/*uart6m1_ctsn conflict with hdmim2_tx1_sda */
	pinctrl-0 = <&uart6m1_xfer &uart6m1_rtsn>;
};

&uart7 {
	status = "okay";
	pinctrl-0 = <&uart7m0_xfer>;
};


&can0{
	status = "okay";
	pinctrl-0 = <&can0m0_pins>;
};

&can1{
	status = "okay";
	pinctrl-0 = <&can1m1_pins>;
};


&i2c2{
	status = "okay";
	pinctrl-names = "default";
	pinctrl-0 = <&i2c2m3_xfer>;
};

&i2c4 {
	status = "okay";
	pinctrl-names = "default";
	pinctrl-0 = <&i2c4m4_xfer>;
	/*clock-frequency = <400000>;*/
};

&i2c6 {
	status = "okay";
	pinctrl-names = "default";
	pinctrl-0 = <&i2c6m0_xfer>;
};

&i2c8 {
	/* conflict with SDIO J2 pins 45 47 */
	status = "disabled";
	pinctrl-names = "default";
	pinctrl-0 = <&i2c8m1_xfer>;
};


&spi0 {
	status = "okay";
	pinctrl-names = "default";
	pinctrl-0 = <&spi0m2_cs0 &spi0m2_cs1 &spi0m2_pins>;
	num-cs = <2>;
};

&spi4 {
	status = "okay";
	pinctrl-names = "default";
	pinctrl-0 = <&spi4m0_cs0 &spi4m0_pins>;
	num-cs = <1>;
};


&u2phy0 {
	status = "okay";
};

&u2phy1 {
	status = "okay";
};


&u2phy2 {
	status = "okay";
};

&u2phy3 {
	status = "okay";
};

&u2phy0_otg {
	rockchip,typec-vbus-det;
	status = "okay";
};

&u2phy1_otg {
	rockchip,typec-vbus-det;
	status = "okay";
};


&u2phy2_host {
	status = "okay";
};

&u2phy3_host {
	status = "okay";
};

&usb_host0_ehci {
	status = "okay";
};

&usb_host0_ohci {
	status = "okay";
};

&usb_host1_ehci {
	status = "okay";
};

&usb_host1_ohci {
	status = "okay";
};

/* USB3.0/DP PHY0 -> in USB3.0 mode, SSRX/SSTX */
&usbdp_phy0 {
	status = "okay";
};

&usbdp_phy0_u3 {
	status = "okay";
};

&usbdrd3_0 {
	status = "okay";
};

&usbdrd_dwc3_0 {
	status = "okay";
};


/* USB3.0/DP PHY1 -> in USB3.0 mode, SSRX/SSTX */
&usbdp_phy1 {
	status = "okay";
};

&usbdp_phy1_u3 {
	status = "okay";
};

&usbdrd3_1 {
	status = "okay";
};

&usbdrd_dwc3_1 {
	status = "okay";
};



&gpio0 {
	gpio-line-names =
		"GPIO0_A0","GPIO0_A1","GPIO0_A2","GPIO0_A3","GPIO0_A4","GPIO0_A5","GPIO0_A6","GPIO0_A7",
		"GPIO0_B0","GPIO0_B1","GPIO0_B2","GPIO0_B3","GPIO0_B4","GPIO0_B5","GPIO0_B6","GPIO0_B7",
		"GPIO0_C0","GPIO0_C1","GPIO0_C2","GPIO0_C3","GPIO0_C4","GPIO0_C5","GPIO0_C6","GPIO0_C7",
		"GPIO0_D0","GPIO0_D1","GPIO0_D2","GPIO0_D3","GPIO0_D4","GPIO0_D5","GPIO0_D6","GPIO0_D7";
};

&gpio1 {
	gpio-line-names =
		"GPIO1_A0","GPIO1_A1","GPIO1_A2","GPIO1_A3","GPIO1_A4","GPIO1_A5","GPIO1_A6","GPIO1_A7",
		"GPIO1_B0","GPIO1_B1","GPIO1_B2","GPIO1_B3","GPIO1_B4","GPIO1_B5","GPIO1_B6","GPIO1_B7",
		"GPIO1_C0","GPIO1_C1","GPIO1_C2","GPIO1_C3","GPIO1_C4","GPIO1_C5","GPIO1_C6","GPIO1_C7",
		"GPIO1_D0","GPIO1_D1","GPIO1_D2","GPIO1_D3","GPIO1_D4","GPIO1_D5","GPIO1_D6","GPIO1_D7";
};

&gpio2 {
	gpio-line-names =
		"GPIO2_A0","GPIO2_A1","GPIO2_A2","GPIO2_A3","GPIO2_A4","GPIO2_A5","GPIO2_A6","GPIO2_A7",
		"GPIO2_B0","GPIO2_B1","GPIO2_B2","GPIO2_B3","GPIO2_B4","GPIO2_B5","GPIO2_B6","GPIO2_B7",
		"GPIO2_C0","GPIO2_C1","GPIO2_C2","GPIO2_C3","GPIO2_C4","GPIO2_C5","GPIO2_C6","GPIO2_C7",
		"GPIO2_D0","GPIO2_D1","GPIO2_D2","GPIO2_D3","GPIO2_D4","GPIO2_D5","GPIO2_D6","GPIO2_D7";
};

&gpio3 {
	gpio-line-names =
		"GPIO3_A0","GPIO3_A1","GPIO3_A2","GPIO3_A3","GPIO3_A4","GPIO3_A5","GPIO3_A6","GPIO3_A7",
		"GPIO3_B0","GPIO3_B1","GPIO3_B2","GPIO3_B3","GPIO3_B4","GPIO3_B5","GPIO3_B6","GPIO3_B7",
		"GPIO3_C0","GPIO3_C1","GPIO3_C2","GPIO3_C3","GPIO3_C4","GPIO3_C5","GPIO3_C6","GPIO3_C7",
		"GPIO3_D0","GPIO3_D1","GPIO3_D2","GPIO3_D3","GPIO3_D4","GPIO3_D5","GPIO3_D6","GPIO3_D7";
};

&gpio4 {
	gpio-line-names =
		"GPIO4_A0","GPIO4_A1","GPIO4_A2","GPIO4_A3","GPIO4_A4","GPIO4_A5","GPIO4_A6","GPIO4_A7",
		"GPIO4_B0","GPIO4_B1","GPIO4_B2","GPIO4_B3","GPIO4_B4","GPIO4_B5","GPIO4_B6","GPIO4_B7",
		"GPIO4_C0","GPIO4_C1","GPIO4_C2","GPIO4_C3","GPIO4_C4","GPIO4_C5","GPIO4_C6","GPIO4_C7",
		"GPIO4_D0","GPIO4_D1","GPIO4_D2","GPIO4_D3","GPIO4_D4","GPIO4_D5","GPIO4_D6","GPIO4_D7";
};

#if HDMIRX
/ {
	reserved-memory {
		#address-cells = <2>;
		#size-cells = <2>;
		ranges;

		/* Reserve 256MB memory for hdmirx-controller@fdee0000 */
		cma {
			compatible = "shared-dma-pool";
			reusable;
			reg = <0x0 (256 * 0x100000) 0x0 (256 * 0x100000)>;
			linux,cma-default;
		};
	};
};

&i2s7_8ch {
	status = "okay";
};

/{
	hdmiin-sound {
		compatible = "rockchip,hdmi";
		rockchip,mclk-fs = <128>;
		rockchip,format = "i2s";
		rockchip,bitclock-master = <&hdmirx_ctrler>;
		rockchip,frame-master = <&hdmirx_ctrler>;
		rockchip,card-name = "rockchip,hdmiin";
		rockchip,cpu = <&i2s7_8ch>;
		rockchip,codec = <&hdmirx_ctrler 0>;
		rockchip,jack-det;
	};
};

/* Should work with at least 128MB cma reserved above. */
&hdmirx_ctrler {
	status = "okay";
	#sound-dai-cells = <1>;
	/* Effective level used to trigger HPD: 0-low, 1-high */
	hpd-trigger-level = <1>;
	hdmirx-det-gpios = <&gpio1 RK_PA7 GPIO_ACTIVE_LOW>;
	pinctrl-names = "default";
	pinctrl-0 = <&hdmim1_rx>;
};
#endif // end HDMIRX


